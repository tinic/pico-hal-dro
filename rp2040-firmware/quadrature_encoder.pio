;
; Copyright (c) 2021 Raspberry Pi (Trading) Ltd.
;
; SPDX-License-Identifier: BSD-3-Clause
;

.program quadrature_encoder

; this code must be loaded at address 0, but at 32 instructions, it probably
; wouldn't be able to share a PIO with anything else anyway
.origin 0


; the code works by running a loop that continuously shifts the 2 phase pins into
; ISR and looks at the lower 4 bits to do a computed jump to an instruction that
; does the proper "do nothing" | "increment" | "decrement" action for that pin
; state change (or no change)

; ISR holds the last state of the 2 pins during most of the code. The Y register
; keeps the current encoder count and is incremented / decremented according to
; the steps sampled

; writing any non zero value to the TX FIFO makes the state machine push the
; current count to RX FIFO between 0 and FFFF_FFFF times. If TX is 0, count
; is pushed once.

; this code assumes 1 instruction per 1 microsecond

; 00 state
JMP update    ; read 00
JMP decrement ; read 01
JMP increment ; read 10
JMP update    ; read 11

; 01 state
JMP increment ; read 00
JMP update    ; read 01
JMP update    ; read 10
JMP decrement ; read 11

; 10 state
JMP decrement ; read 00
JMP update    ; read 01
JMP update    ; read 10
JMP increment ; read 11

; to reduce code size, the last 2 states are implemented in place and become the
; target for the other jumps

; 11 state
JMP update    ; read 00
JMP increment ; read 01
JMP decrement ; read 10
; JMP update    ; read 11
.wrap_target
update:
; for a clockwise rotating encoder, you'd normally have the following pattern:
; 00 -> 10 -> 11 -> 01 -> 00 -> ...
;
; for a counter-clockwise rotating encoder, you'd normally have:
; 11 -> 10 -> 00 -> 01 -> 11 -> ...
;
; so depending on the current state and the state that follows, we know whether
; to increment or decrement. E.g. delta (11->00) is +1, whereas (00->11) is -1, etc.
    push noblock  ; TX FIFO not empty? push current count to RX FIFO
    mov isr y     ; store current count for PUSH
    pull noblock  ; pull number of times to push from TX FIFO
    jmp !x update_done
push_n:
    push noblock
    jmp x-- push_n
update_done:
    in pins 2     ; read phase pins
.wrap

increment:
    jmp y-- increment_cont
    set y 31
increment_cont:
    jmp update

decrement:
    mov x ~y
    jmp x-- decrement_cont
decrement_cont:
    mov y ~x
    jmp update


% c-sdk {
static inline void quadrature_encoder_program_init(PIO pio, uint sm, uint offset, uint pin, int max_step_rate)
{
    pio_sm_set_consecutive_pindirs(pio, sm, pin, 2, false);

    pio_gpio_init(pio, pin);
    pio_gpio_init(pio, pin + 1);

    pio_sm_config c = quadrature_encoder_program_get_default_config(offset);
    sm_config_set_in_pins(&c, pin); // for WAIT, IN
    sm_config_set_jmp_pin(&c, pin); // for JMP
    // shift to left, autopull disabled
    sm_config_set_in_shift(&c, false, false, 32);
    // don't join FIFO's
    sm_config_set_fifo_join(&c, PIO_FIFO_JOIN_NONE);

    // passing "0" as the sample frequency,
    if (max_step_rate == 0) {
        sm_config_set_clkdiv(&c, 1.0);
    } else {
        // one state machine loop takes at most 10 cycles
        float div = (float)clock_get_hz(clk_sys) / (10 * max_step_rate);
        sm_config_set_clkdiv(&c, div);
    }

    pio_sm_init(pio, sm, offset, &c);
    pio_sm_set_enabled(pio, sm, true);
}


// When requesting the current count we may have to wait a few cycles (average
// ~11 sysclk cycles) for the state machine to reply. If we are reading multiple
// encoders, we may request them all in one go and then fetch them all, thus
// avoiding doing the wait multiple times. If we are reading just one encoder,
// we can use the "get_count" function to request and wait

static inline void quadrature_encoder_request_count(PIO pio, uint sm)
{
    pio->txf[sm] = 1;
}

static inline int32_t quadrature_encoder_fetch_count(PIO pio, uint sm)
{
    while (pio_sm_is_rx_fifo_empty(pio, sm))
        tight_loop_contents();
    return pio->rxf[sm];
}

static inline int32_t quadrature_encoder_get_count(PIO pio, uint sm)
{
    quadrature_encoder_request_count(pio, sm);
    return quadrature_encoder_fetch_count(pio, sm);
}
%}